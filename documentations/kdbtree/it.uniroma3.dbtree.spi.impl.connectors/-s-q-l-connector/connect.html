<HTML>
<HEAD>
<meta charset="UTF-8">
<title>SQLConnector.connect - kdbtree</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">kdbtree</a>&nbsp;/&nbsp;<a href="../index.html">it.uniroma3.dbtree.spi.impl.connectors</a>&nbsp;/&nbsp;<a href="index.html">SQLConnector</a>&nbsp;/&nbsp;<a href="./connect.html">connect</a><br/>
<br/>
<h1>connect</h1>
<a name="it.uniroma3.dbtree.spi.impl.connectors.SQLConnector$connect(kotlin.String, kotlin.Int, kotlin.String)"></a>
<code><span class="keyword">fun </span><span class="identifier">connect</span><span class="symbol">(</span><span class="identifier" id="it.uniroma3.dbtree.spi.impl.connectors.SQLConnector$connect(kotlin.String, kotlin.Int, kotlin.String)/aggrFunName">aggrFunName</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">, </span><span class="identifier" id="it.uniroma3.dbtree.spi.impl.connectors.SQLConnector$connect(kotlin.String, kotlin.Int, kotlin.String)/maxLevel">maxLevel</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">, </span><span class="identifier" id="it.uniroma3.dbtree.spi.impl.connectors.SQLConnector$connect(kotlin.String, kotlin.Int, kotlin.String)/initRootContext">initRootContext</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code> <a href="https://github.com/kdbtree/kdbtree/src/main/kotlin/it/uniroma3/dbtree/spi/impl/connectors/SQLConnector.kt#L85">(source)</a>
<p>Connects with the underlying database.</p>
<p>The connection should either recover the state left by the previous close(), or (in case no previous
state is found) start a new one.</p>
<p>Connector should make sure that:</p>
<ul><li>The connection will be opened on the existing target table, if present, otherwise a new one will be created.</li>
<li>The target table name should be: "tableName_aggrFunName_kpName" to achieve a unique identification.</li>
<li>
<p>The target table must be provided with the following columns, in order:</p>
  <ul><li>level: of type Int.</li>
  <li>k_min: can span more columns. Its definition is specified by the KeyParser kp.</li>
  <li>k_max: can span more columns. Its definition is specified by the KeyParser kp.</li>
  <li>context: of type String. It will contain the node's serialized elements.</li>
</ul>
</li>
<li>If a valid target table is found, Connector should ask the client whether he wants to connect or to overwrite
previous data and start a new state (old table is emptied and re-populated).</li>
</ul>
<h3>Parameters</h3>
<p><a name="aggrFunName"></a>
<code>aggrFunName</code> - the aggregation function's name.</p>
<p><a name="maxLevel"></a>
<code>maxLevel</code> - the level of the root for the DB-tree.</p>
<p><a name="initRootContext"></a>
<code>initRootContext</code> - the identity aggregate value (for the root) wrt the aggregation function.</p>
</BODY>
</HTML>
